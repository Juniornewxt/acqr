package main

import (
	"bufio"
	"bytes"
	"fmt"
	"net"
	"os"
	"time"
)

const tamanhoBuffer = 1024 // Tamanho do buffer para leitura de dados

func main() {

	fmt.Println("Servidor aguardando conexões...")

	// ouvindo na porta 8081 via protocolo tcp/ip
	ln, erro1 := net.Listen("tcp", ":8081")
	if erro1 != nil {
		fmt.Println(erro1)
		os.Exit(1)
	}

	defer ln.Close()

	// rodando loop contínuo (até que ctrl-c seja acionado)
	for {
		// aceitando conexões
		conexao, erro2 := ln.Accept()
		if erro2 != nil {
			fmt.Println(erro2)
			continue // continua esperando por outras conexões
		}

		fmt.Println("Conexão aceita...")
		// Chama go para que suporte varias conexoes.
		go handleConnection(conexao)
	}
}

func handleConnection(conexao net.Conn) {
	defer conexao.Close()

	// buffer para leitura de dados
	buffer := make([]byte, tamanhoBuffer)

	for {
		// define um prazo de leitura para evitar esperar indefinidamente
		conexao.SetReadDeadline(time.Now().Add(5 * time.Second))

		// lê os dados da conexão
		recebida_formatada, err := conexao.Read(buffer)
		if err != nil {
			if os.IsTimeout(err) {
				// Timeout atingido, reinicia o prazo de leitura
				conexao.SetReadDeadline(time.Time{})
				continue
			}
			fmt.Println("Erro ao ler a mensagem:", err)
			return
		}

		// mensagem recebida
		mensagem := string(buffer[:recebida_formatada])
		fmt.Println("Mensagem recebida:", mensagem)

		// envia a mensagem para o outro servidor e obtém a resposta
		resposta, err := encaminhaMensagem(mensagem, "localhost:9010")
		if err != nil {
			fmt.Println("Erro ao encaminhar mensagem:", err)
			conexao.Write([]byte("Erro ao processar sua mensagem.\n"))
			continue
		}

		// envia a resposta de volta para o cliente
		conexao.Write([]byte(resposta))
		fmt.Println("Resposta enviada:", resposta)

	}
}

func encaminhaMensagem(mensagem, endereco string) (string, error) {
	// conecta ao outro servidor
	tcpAddr, err := net.ResolveTCPAddr("tcp", endereco)
	if err != nil {
		println("FALHA AO RESOLVER ENDERECO IP BANDEIRA:", err.Error())
		//os.Exit(1)
	}
	conn, err := net.DialTCP("tcp", nil, tcpAddr)
	if err != nil {
		return "", err

	}
	defer conn.Close()

	var buf bytes.Buffer
	// define um prazo de leitura para evitar esperar indefinidamente
	conn.SetReadDeadline(time.Now().Add(5 * time.Second))
	// escreve a mensagem
	_, err = buf.Write([]byte(mensagem))

	// envia a mensagem
	_, err = conn.Write(buf.Bytes())
	//_, err = conn.Write([]byte(mensagem))
	if err != nil {
		return "", err
	}

	// lê a resposta
	bufReader := bufio.NewReader(conn)

	recvBuf := make([]byte, tamanhoBuffer)
	recebida_formatada, err := bufReader.Read(recvBuf)
	retorno := string(recvBuf[:recebida_formatada])
	//fmt.Print("\n Message from server: " + string(retorno))

	//retorna a mensagem para o servidor enviar ao terminal
	return retorno, err

}
