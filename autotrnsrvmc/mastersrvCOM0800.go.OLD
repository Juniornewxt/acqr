package main

import (
	"bufio"
	"bytes"
	"fmt"
	"io"
	"log"
	"net"
	"os"
	"time"

	//"projetoacqr/admserver"
	"projetoacqr/manipulaiso"
	"projetoacqr/separaiso"
)

const tamanhoBuffer = 1024 // Tamanho do buffer para leitura de dados

func main() {
	//portaMC := "localhost:9010"
	// Conecta ao servidor externo na porta 9010 ao iniciar o servidor
	externalConn, err := net.Dial("tcp", "localhost:8080")
	if err != nil {
		log.Fatalf("Erro ao conectar ao servidor externo na porta 9010: %v", err)
	}
	defer externalConn.Close()
	log.Println("Conectado ao servidor externo na porta 9010")

	// Goroutine para monitorar e processar mensagens do servidor externo
	go handleExternalMessages(externalConn)

	fmt.Println("Servidor aguardando conexões...")

	// ouvindo na porta 8081 via protocolo tcp/ip
	ln, erro1 := net.Listen("tcp", ":8081")
	if erro1 != nil {
		fmt.Println(erro1)
		os.Exit(1)
	}

	defer ln.Close()

	// rodando loop contínuo (até que ctrl-c seja acionado)
	for {
		// aceitando conexões
		conexao, erro2 := ln.Accept()
		if erro2 != nil {
			fmt.Println(erro2)
			continue // continua esperando por outras conexões
		}

		fmt.Println("Conexão aceita...")
		// Chama go para que suporte varias conexoes.
		go handleConnection(conexao)
		//go admserver.Cliente0800()
	}
}

func handleConnection(conexao net.Conn) {
	defer conexao.Close()

	// buffer para leitura de dados
	buffer := make([]byte, tamanhoBuffer)
	//fmt.Println("Mensagem recebida1:", buffer)
	recebida_formatada1, err := conexao.Read(buffer)
	if err != nil {
		fmt.Println("Erro ao ler mensagem para encaminhar a func iso MC:", err)
		return
	}
	mensagem1 := string(buffer[:recebida_formatada1])
	fmt.Println("Mensagem recebida1:", mensagem1)
	msn, err := separaiso.Mciso(buffer)
	if err != nil {
		fmt.Println("Erro ao encaminhar mensagem iso MC:", err)
		return
	}
	///msn = make([]byte, tamanhoBuffer)
	fmt.Println("Mensagem recebida2:", msn)

	// define um prazo de leitura para evitar esperar indefinidamente
	conexao.SetReadDeadline(time.Now().Add(5 * time.Second))
	recebida_formatada := msn

	// lê os dados da conexão
	if err != nil {
		if os.IsTimeout(err) {
			// Timeout atingido, reinicia o prazo de leitura
			conexao.SetReadDeadline(time.Time{})
			//continue
		}
		fmt.Println("Erro ao ler a mensagem:", err)
		return
	}

	// mensagem recebida
	//mensagem := string(recebida_formatada)
	mensagem := string(recebida_formatada)
	fmt.Println("Mensagem recebida do MC:", mensagem)

	// envia a mensagem para o outro servidor e obtém a resposta
	//resposta, err := encaminhaMensagem(mensagem, "localhost:9010")
	resposta, err := encaminhaMensagem(mensagem, "localhost:8080")
	if err != nil {
		fmt.Println("Erro ao encaminhar mensagem:", err)
		conexao.Write([]byte("Erro ao processar sua mensagem.\n"))
		//continue
	}
	// Envia para func de trabalha a iso padrao
	msn2, err := manipulaiso.Padraoiso([]byte(resposta))
	if err != nil {
		fmt.Println("Erro ao encaminhar mensagem iso parao:", err)
		return
	}
	// envia a resposta de volta para o cliente
	conexao.Write([]byte(msn2))
	fmt.Println("Resposta enviada:", string(msn2))

}

func encaminhaMensagem(mensagem, endereco string) (string, error) {
	// conecta ao outro servidor
	tcpAddr, err := net.ResolveTCPAddr("tcp", endereco)
	if err != nil {
		println("FALHA AO RESOLVER ENDERECO IP BANDEIRA:", err.Error())
		//os.Exit(1)
	}
	conn, err := net.DialTCP("tcp", nil, tcpAddr)
	if err != nil {
		return "", err

	}
	defer conn.Close()

	var buf bytes.Buffer
	// define um prazo de leitura para evitar esperar indefinidamente
	conn.SetReadDeadline(time.Now().Add(5 * time.Second))
	// escreve a mensagem
	_, err = buf.Write([]byte(mensagem))
	if err != nil {
		return "", err
	}

	// envia a mensagem
	_, err = conn.Write(buf.Bytes())
	if err != nil {
		return "", err
	}

	// lê a resposta
	bufReader := bufio.NewReader(conn)

	recvBuf := make([]byte, tamanhoBuffer)
	recebida_formatada, err := bufReader.Read(recvBuf)
	retorno := string(recvBuf[:recebida_formatada])
	//fmt.Print("\n Message from server: " + string(retorno))

	//retorna a mensagem para o servidor enviar ao terminal
	return retorno, err

}

// Função para monitorar e processar mensagens do servidor externo
func handleExternalMessages(externalConn net.Conn) {
	buf := make([]byte, 1024)
	for {
		n, err := externalConn.Read(buf)
		if err != nil {
			if err != io.EOF {
				log.Printf("Erro ao ler do servidor externo: %v", err)
			}
			break
		}
		if n > 0 {
			message := buf[:n]
			log.Printf("Mensagem recebida do servidor externo: %s", string(message))

			// Aqui você pode implementar qualquer lógica para lidar com a mensagem recebida
			if isUnsolicitedMessage(message) {
				//sendBackToPort9010(message, externalConn)
			} else {
				log.Println("Mensagem recebida não foi identificada como não solicitada.")
			}
		}
	}
}

// Função para determinar se uma mensagem é não solicitada
func isUnsolicitedMessage(msg []byte) bool {
	fmt.Println("MENSAGEM RECEBI PARA ENCAMININHAR 0800", msg)
	// Implementar a lógica para identificar mensagens não solicitadas
	return false
}
