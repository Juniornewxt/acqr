package trabalhaconexoes

import (
	"fmt"
	"log"
	"net"
	"os"
	"strconv"
	"time"

	"projetoacqr/gerenciamento"
	"projetoacqr/manipulaiso"
	"projetoacqr/separaiso"

	"github.com/joho/godotenv"
)

// Variável para controlar se a mensagem completa será logada
var logMSNrede bool

// Variável para controlar se a mensagem de confirmacao é enviada
var msnMTI180 bool

// Tamanho do buffer para leitura de dados
const tamanhoBuffer = 1024

// handleConnection lida com uma única conexão de cliente
func TrabalhaConexao(conexao net.Conn) {
	defer conexao.Close()

	// Carrega as variáveis de ambiente do arquivo .env
	if err := godotenv.Load(); err != nil {
		log.Fatalf("Erro ao carregar o arquivo .env: %v", err)
	}

	// Configura se deve logar a mensagem completa
	logMSNrede = os.Getenv("LOG_MSN_REDE") == "true"

	// Configura se deve enviar a mensagem de confirmacao mti180
	msnMTI180 = os.Getenv("ISO_CONFIRM") == "true"

	// Buffer para receber a mensagem
	msnbuffer := make([]byte, tamanhoBuffer)

	// Lê a mensagem recebida
	recebidaFormatada, err := conexao.Read(msnbuffer)
	if err != nil {
		log.Printf("Erro ao ler mensagem: %v", err)
		return
	}

	// Log da mensagem recebida
	mensagemRecebida := string(msnbuffer[:recebidaFormatada])
	//gerenciamento.LogMensagens("Recebido", mensagemRecebida[:8], conexao.RemoteAddr(), conexao.LocalAddr())

	mensagemDevolver, err := TrabalhaConexaoProcessaDados(mensagemRecebida)
	//fmt.Println("ISO RECEBIDA DA FUNCAO", mensagemDevolver)
	// Verifica se deve logar a mensagem completa
	logMSNredeDefinida := os.Getenv("MSN_DEFINIDA")
	if logMSNrede {
		gerenciamento.LogMensagens("Recebido", mensagemRecebida, conexao.RemoteAddr(), conexao.LocalAddr())
	} else {
		gerenciamento.LogMensagens("Recebido", logMSNredeDefinida, conexao.RemoteAddr(), conexao.LocalAddr())
	}

	// Processa a mensagem através da função de separação ISO
	//msn, err := separaiso.Mciso(msnbuffer)
	//if err != nil {
	//	log.Printf("Erro ao processar mensagem ISO MC: %v", err)
	//	return
	//}

	// Define timeout para leitura do servidor do cliente
	clienteTimeout := os.Getenv("CLIENTTIMOUT")
	clienteTimeoutf, err := strconv.Atoi(clienteTimeout)
	if err != nil {
		log.Println("Falha ao enviar a mensagem, erro ao converter string para int CLIENTTIMOUT:", err)
		return
	}
	conexao.SetReadDeadline(time.Now().Add(time.Duration(clienteTimeoutf) * time.Second))
	//conexao.SetReadDeadline(time.Now().Add(5 * time.Second))

	// Envia a mensagem para outro servidor e obtém a resposta
	//tcpHPortaMC := os.Getenv("TCP_HP_MC")
	//resposta, err := encaminhaMensagem(string(msn), tcpHPortaMC, conexao.RemoteAddr())
	//if err != nil {
	//log.Printf("Erro ao encaminhar mensagem: %v", err)
	//	conexao.Write([]byte("Erro ao processar sua mensagem.\n"))
	// Prepara a resposta final para o cliente
	//	msn3, err := manipulaiso.Padraoiso100erro([]byte(msnbuffer))
	//	if err != nil {
	//log.Printf("Erro ao formatar resposta para cliente: %v", err)
	//return
	//	}

	// Envia a resposta ao cliente com erro
	//	conexao.Write([]byte(msn3))
	//	if logMSNrede {
	//		gerenciamento.LogMensagens("Recebido", string(msn3), conexao.LocalAddr(), conexao.RemoteAddr())
	//	} else {
	//		gerenciamento.LogMensagens("Recebido", logMSNredeDefinida, conexao.LocalAddr(), conexao.RemoteAddr())
	//	}
	//		//return
	//	}
	// Inicia processo de envio ou nao de mensagem de confirmacao
	//if msnMTI180 {
	//		// Processa a confirmação da mensagem de autorização
	//	msnConfirm, err := separaiso.MCoutrosiso([]byte(resposta))
	//	if err != nil {
	//			log.Printf("Erro ao processar confirmação MC: %v", err)
	//		return
	//	}
	// Envia confirmação sem esperar resposta
	//	if err := encaminhaMsnSemRet(string(msnConfirm), tcpHPortaMC, conexao.RemoteAddr()); err != nil {
	//		log.Printf("Erro ao enviar confirmação: %v", err)
	//	}
	//} else {
	//		log.Println("MENSAGEM DE CONFIRMACAO NAO ENVIADA ESTA DESATIVADA")
	//	}

	// Prepara a resposta final para o cliente
	//	msn2, err := separaiso.Padraoiso([]byte(resposta))
	//	if err != nil {
	//		log.Printf("Erro ao formatar resposta para cliente: %v", err)
	//		return
	//	}

	// Envia a resposta ao cliente
	conexao.Write([]byte(mensagemDevolver))
	//gerenciamento.LogMensagens("Enviado", string(msn2)[:8], conexao.LocalAddr(), conexao.RemoteAddr())
	// Verifica se deve logar a mensagem completa
	//logMSNredeDefinida := os.Getenv("MSN_DEFINIDA")
	if logMSNrede {
		gerenciamento.LogMensagens("Recebido", string(mensagemDevolver), conexao.LocalAddr(), conexao.RemoteAddr())
	} else {
		gerenciamento.LogMensagens("Recebido", logMSNredeDefinida, conexao.LocalAddr(), conexao.RemoteAddr())
	}
}

// encaminhaMensagem envia a mensagem para outro servidor e retorna a resposta
func encaminhaMensagem(mensagem, endereco string, srcAddr net.Addr) (string, error) {
	// Definir timeout para a conexão com servidor externo
	mcTimeout := os.Getenv("MCTIMEOUT")
	mcTimeoutf, err := strconv.Atoi(mcTimeout)
	if err != nil {
		log.Println("Falha ao enviar a mensagem, erro ao converter string para int MCTIMEOUT:", err)
	}
	timeout := time.Duration(mcTimeoutf) * time.Second
	//timeout := 1 * time.Second
	dialer := net.Dialer{
		Timeout: timeout, // Timeout de conexão
	}

	// Estabelece a conexão TCP com o servidor de destino com timeout de conexão
	conn, err := dialer.Dial("tcp", endereco)
	if err != nil {
		log.Printf("Erro ao conectar ao servidor de destino: %v", err)
		return "", err
	}
	defer conn.Close()

	// Aplica o timeout para leitura e escrita (ambos)
	conn.SetDeadline(time.Now().Add(timeout))

	// Envia a mensagem para o servidor de destino
	if _, err := conn.Write([]byte(mensagem)); err != nil {
		return "", err
	}

	// Buffer para armazenar a resposta
	recvBuf := make([]byte, tamanhoBuffer)

	// Lê a resposta do servidor de destino
	recebidaFormatada, err := conn.Read(recvBuf)
	if err != nil {
		// Verifica se o erro foi causado por um timeout
		if netErr, ok := err.(net.Error); ok && netErr.Timeout() {
			log.Printf("Timeout ao ler a resposta do servidor de destino.")
			return "", err
		}
		log.Printf("Erro ao ler a resposta do servidor de destino: %v", err)
		return "", err
	}

	retorno := string(recvBuf[:recebidaFormatada])

	// Verifica se deve logar a mensagem completa
	//logMSNredeDefinida := os.Getenv("MSN_DEFINIDA")
	//	if logMSNrede {
	//	gerenciamento.LogMensagens("Recebido", retorno, conn.RemoteAddr(), srcAddr)
	//} else {
	//	gerenciamento.LogMensagens("Recebido", logMSNredeDefinida, conn.RemoteAddr(), srcAddr)
	//}

	return retorno, nil
}

// encaminhaMsnSemRet apenas envia a mensagem, sem esperar retorno
func encaminhaMsnSemRet(mensagem, endereco string, srcAddr net.Addr) error {
	tcpAddr, err := net.ResolveTCPAddr("tcp", endereco)
	if err != nil {
		log.Printf("Erro ao resolver endereço: %v", err)
		return err
	}

	conn, err := net.DialTCP("tcp", nil, tcpAddr)
	if err != nil {
		log.Printf("Erro ao conectar ao servidor de destino: %v", err)
		return err
	}
	defer conn.Close()

	// Envia a mensagem
	if _, err := conn.Write([]byte(mensagem)); err != nil {
		return err
	}

	// Log da mensagem enviada
	//gerenciamento.LogMensagens("Enviado", mensagem[:8], srcAddr, conn.RemoteAddr())
	// Verifica se deve logar a mensagem completa
	//logMSNredeDefinida := os.Getenv("MSN_DEFINIDA")
	//if logMSNrede {
	//	gerenciamento.LogMensagens("Recebido", mensagem, srcAddr, conn.RemoteAddr())
	//} else {
	//	gerenciamento.LogMensagens("Recebido", logMSNredeDefinida, srcAddr, conn.RemoteAddr())
	//}

	// Não aguarda resposta
	return nil
}

// TrabalhaConexaoProcessaDados lida com a lógica de processar mensagens, independente da conexão
func TrabalhaConexaoProcessaDados(mensagemRecebida string) (string, error) {
	// Processamento da mensagem
	msn, err := separaiso.Mciso([]byte(mensagemRecebida))
	if err != nil {
		log.Printf("Erro ao processar mensagem ISO MC: %v", err)
		return "", err
	}
	//logMSNredeDefinida := os.Getenv("MSN_DEFINIDA")
	// Envia a mensagem para outro servidor e obtém a resposta
	tcpHPortaMC := os.Getenv("TCP_HP_MC")
	resposta, err := encaminhaMensagem(string(msn), tcpHPortaMC, nil)
	if err != nil {
		log.Printf("Erro ao encaminhar mensagem: %v", err)
		//return "Erro ao processar sua mensagem.\n", err
		// Prepara a resposta final para o cliente
		msn3, err := manipulaiso.Padraoiso100erro([]byte(mensagemRecebida))
		if err != nil {
			log.Printf("Erro ao formatar resposta para cliente: %v", err)
			return "", err
		}
		fmt.Println("ERRO FEITO NA FUNCAO NOVA!!!")
		fmt.Println("ERRO FEITO NA FUNCAO NOVA!!!", msn3)
		// Envia a resposta ao cliente com erro
		//if logMSNrede {
		//	gerenciamento.LogMensagens("Recebido", string(msn3), nil, nil)
		//} else {
		//	gerenciamento.LogMensagens("Recebido", logMSNredeDefinida, nil, nil)
		//}
		return string(msn3), nil
		//conexao.Write([]byte(msn3))
		//return "", err
	}
	// Configura se deve enviar a mensagem de confirmacao mti180
	msnMTI180 = os.Getenv("ISO_CONFIRM") == "true"
	// Inicia processo de envio ou nao de mensagem de confirmacao
	if msnMTI180 {
		// Processa a confirmação da mensagem de autorização
		msnConfirm, err := separaiso.MCoutrosiso([]byte(resposta))
		if err != nil {
			log.Printf("Erro ao processar confirmação MC: %v", err)
			//return
		}
		// Envia confirmação sem esperar resposta
		if err := encaminhaMsnSemRet(string(msnConfirm), tcpHPortaMC, nil); err != nil {
			log.Printf("Erro ao enviar confirmação: %v", err)
		}
	} else {
		log.Println("MENSAGEM DE CONFIRMACAO NAO ENVIADA ESTA DESATIVADA")
	}

	// Prepara a resposta final
	msn2, err := separaiso.Padraoiso([]byte(resposta))
	if err != nil {
		log.Printf("Erro ao formatar resposta para cliente: %v", err)
		return "", err
	}
	fmt.Println("FEITO NA FUNCAO NOVA!!!")
	fmt.Println("FEITO NA FUNCAO NOVA!!!", msn2)
	return string(msn2), nil
}
